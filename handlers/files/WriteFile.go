// Package files is generated by Handlergenerator tooling
// Make sure to insert real Description here
package files

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os"

	"github.com/percybolmer/workflow/payload"
	"github.com/percybolmer/workflow/property"
	"github.com/percybolmer/workflow/register"
)

// WriteFile is used to $INSERT DESCRIPTION
type WriteFile struct {
	// Cfg is values needed to properly run the Handle func
	Cfg     *property.Configuration `json:"configs" yaml:"configs"`
	Name    string                  `json:"name" yaml:"handler_name"`
	path    string
	append  bool
	forward bool

	subscriptionless bool
}

var (
	//ErrBadWriteData is thrown when the size written to file is not the same as the payload
	ErrBadWriteData error = errors.New("the size written to file does not match the payload")
	//ErrFileExists is when trying to write to Files that already exist, but Append is set to false
	ErrFileExists = errors.New("trying to write to file that already exists, but append is false")
)

func init() {
	register.Register("WriteFile", NewWriteFileHandler())
}

// NewWriteFileHandler generates a new WriteFile Handler
func NewWriteFileHandler() *WriteFile {
	act := &WriteFile{
		Cfg: &property.Configuration{
			Properties: make([]*property.Property, 0),
		},
		Name: "WriteFile",
	}
	act.Cfg.AddProperty("path", "the path on where to write files", true)
	act.Cfg.AddProperty("append", "if set to true it will append to files instead of overwriting collisions", true)
	act.Cfg.AddProperty("forward", "if set to true it will output the payload after writing it", true)
	return act
}

// GetHandlerName is used to retrun a unqiue string name
func (a *WriteFile) GetHandlerName() string {
	return a.Name
}

// Handle is used to write files to disc
func (a *WriteFile) Handle(input payload.Payload) ([]payload.Payload, error) {

	finfo, err := os.Stat(a.path)
	if err != nil && !os.IsNotExist(err) {
		return nil, err
	}

	if finfo != nil && finfo.IsDir() {
		// Write is to a folder, No need for error, but lets create a random name with tmpfile
		file, err := ioutil.TempFile(a.path, "WriteFile_")
		if err != nil {
			return nil, err
		}
		err = write(file, input.GetPayload())
		if err != nil {
			return nil, err
		}
	} else {
		if finfo != nil && !a.append {
			// We dont want to write to files that exists if append is false
			return nil, ErrFileExists
		}
		file, err := os.OpenFile(a.path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
		if err != nil {
			return nil, err
		}
		_, err = fmt.Fprintf(file, "\n%s", string(input.GetPayload()))
		if err != nil {
			return nil, err
		}
	}

	if a.forward {
		output := make([]payload.Payload, 0)
		output = append(output, input)
		return output, nil
	}
	return nil, nil

}

// write is a function that takes a file, close it and writes to it.. in reverse order ofcourse:)
func write(file *os.File, data []byte) error {
	defer file.Close()
	n, err := file.Write(data)
	if err != nil {
		return err
	}
	if n != len(data) {
		return ErrBadWriteData
	}
	return nil
}

// ValidateConfiguration is used to see that all needed configurations are assigned before starting
func (a *WriteFile) ValidateConfiguration() (bool, []string) {
	// Check if Cfgs are there as needed
	missing := make([]string, 0)

	pathProp := a.Cfg.GetProperty("path")
	appendProp := a.Cfg.GetProperty("append")
	forwardProp := a.Cfg.GetProperty("forward")

	valid, missing := a.Cfg.ValidateProperties()
	if !valid {
		return false, missing
	}

	path := pathProp.String()
	app, err := appendProp.Bool()
	if err != nil {
		return false, append(missing, err.Error())
	}

	forward, err := forwardProp.Bool()
	if err != nil {
		return false, append(missing, err.Error())
	}

	a.path = path
	a.append = app
	a.forward = forward
	return true, nil
}

// GetConfiguration will return the CFG for the Handler
func (a *WriteFile) GetConfiguration() *property.Configuration {
	return a.Cfg
}

// Subscriptionless will return true/false if the Handler is genereating payloads itself
func (a *WriteFile) Subscriptionless() bool {
	return a.subscriptionless
}
