// Package network is generated by Handlergenerator tooling
// Make sure to insert real Description here
package network

import (
	"context"
	"errors"
	"fmt"

	"github.com/google/gopacket/pcap"
	"github.com/percybolmer/workflow/metric"
	"github.com/percybolmer/workflow/payload"
	"github.com/percybolmer/workflow/property"
	"github.com/percybolmer/workflow/register"
)

var (
	//ErrNoDevicesFound is when the system has no network interfaces to sniff on
	ErrNoDevicesFound = errors.New("no sniffable devices found on the system")
	//ErrConfiguredInterface is thrown when the wanted interface does not exist
	ErrConfiguredInterface = errors.New("there is no such interface, try checking your systems network interfaces names")
)

// NetworkInterface is used to read packets from a network interface
type NetworkInterface struct {
	// Cfg is values needed to properly run the Handle func
	Cfg *property.Configuration `json:"configs" yaml:"configs"`
	// Name is sort of like an ID used to load data back should be the same that is used to register the Handler
	Name string `json:"handler_name" yaml:"handler_name"`
	// subscriptionless should be set to true if this Handler does not need any input payloads to function
	subscriptionless bool
	// bpf is used to apply a bpf filter
	bpf string
	// netinterface is the network interface to read from
	netinterface *pcap.Interface
	// snapshotlength
	snapshotlength int32
	// link layer
	// prommode
	prommode bool

	errChan      chan error
	metrics      metric.Provider
	metricPrefix string
	// MetricPayloadOut is how many payloads the processor has outputted
	MetricPayloadOut string
	// MetricPayloadIn is how many payloads the processor has inputted
	MetricPayloadIn string
}

func init() {
	register.Register("NetworkInterface", NewNetworkInterfaceHandler())
}

// NewNetworkInterfaceHandler generates a new NetworkInterface Handler
func NewNetworkInterfaceHandler() *NetworkInterface {
	act := &NetworkInterface{
		Cfg: &property.Configuration{
			Properties: make([]*property.Property, 0),
		},
		Name:             "NetworkInterface",
		subscriptionless: true,
		snapshotlength:   65536,
		prommode:         true,
		errChan:          make(chan error, 1000),
	}

	act.Cfg.AddProperty("bpf", "A bpf filter to be used on the input interface", false)

	act.Cfg.AddProperty("interface", "The interface to read network traffic from", true)
	return act
}

// GetHandlerName should return the name of the handler that was used in register
func (a *NetworkInterface) GetHandlerName() string {
	return a.Name
}

// Handle is used to $INSERT DESCRIPTION HERE
func (a *NetworkInterface) Handle(ctx context.Context, input payload.Payload, topics ...string) error {

	/**
	handle, err := pcap.OpenLive(n.selectedInterface.Name, n.snapShotLength, n.promiscousMode, 30*time.Second)
	if err != nil {
		fmt.Printf("Error opening device %s: %v", n.selectedInterface.Name, err)
	}
	*/
	return nil
}

// ValidateConfiguration is used to see that all needed configurations are assigned before starting
func (a *NetworkInterface) ValidateConfiguration() (bool, []string) {
	// Check if Cfgs are there as needed
	valid, miss := a.Cfg.ValidateProperties()
	if !valid {
		return valid, miss
	}
	bpfProp := a.Cfg.GetProperty("bpf")
	if bpfProp != nil && bpfProp.Value != nil {
		a.bpf = bpfProp.String()
	}
	interfaceProp := a.Cfg.GetProperty("interface")
	if interfaceProp == nil || interfaceProp.Value == nil {
		return false, []string{"Missing interface property"}
	}
	wantedInterface := interfaceProp.String()
	availableInterfaces, err := FindDevices()
	if err != nil {
		return false, []string{err.Error()}
	}
	for _, interf := range availableInterfaces {
		if interf.Name == wantedInterface {
			a.netinterface = &interf
		}
	}
	if a.netinterface == nil {
		return false, []string{ErrConfiguredInterface.Error()}
	}
	// ADD CHUNK SIZE
	// ADD DELAY OR WAIT TIMER BEFORE PUBLISHING X PACKETS
	// Default snapshot length
	// Link layer type

	return true, nil
}

// GetConfiguration will return the CFG for the Handler
func (a *NetworkInterface) GetConfiguration() *property.Configuration {
	return a.Cfg
}

// Subscriptionless will return true/false if the Handler is genereating payloads itself
func (a *NetworkInterface) Subscriptionless() bool {
	return a.subscriptionless
}

// FindDevices prints all network interface info
func FindDevices() ([]pcap.Interface, error) {
	devices, err := pcap.FindAllDevs()
	if err != nil {
		return nil, err
	}
	if len(devices) == 0 {
		return nil, ErrNoDevicesFound
	}
	return devices, nil
}

// GetErrorChannel will return a channel that the Handler can output eventual errors onto
func (a *NetworkInterface) GetErrorChannel() chan error {
	return a.errChan
}

// SetMetricProvider is used to change what metrics provider is used by the handler
func (a *NetworkInterface) SetMetricProvider(p metric.Provider, prefix string) error {
	a.metrics = p
	a.metricPrefix = prefix

	a.MetricPayloadIn = fmt.Sprintf("%s_payloads_in", prefix)
	a.MetricPayloadOut = fmt.Sprintf("%s_payloads_out", prefix)
	err := a.metrics.AddMetric(&metric.Metric{
		Name:        a.MetricPayloadOut,
		Description: "keeps track of how many payloads the handler has outputted",
	})
	if err != nil {
		return err
	}
	err = a.metrics.AddMetric(&metric.Metric{
		Name:        a.MetricPayloadIn,
		Description: "keeps track of how many payloads the handler has ingested",
	})
	return err
}
