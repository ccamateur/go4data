// Package network is generated by Handlergenerator tooling
// OpenPcap will open up a pcap and output all network packets to the next processor
package network

import (
	"github.com/google/gopacket"
	"github.com/google/gopacket/pcap"
	"github.com/percybolmer/workflow/payload"
	"github.com/percybolmer/workflow/property"
	"github.com/percybolmer/workflow/register"
)

// OpenPcap is used to open up a PCAP and Read the packets from the pcap.
type OpenPcap struct {
	// Cfg is values needed to properly run the Handle func
	Cfg *property.Configuration `json:"configs" yaml:"configs"`
	// Name is sort of like an ID used to load data back should be the same that is used to register the Handler
	Name string `json:"handler_name yaml:"handler_name"`

	// subscriptionless should be set to true if this Handler does not need any input payloads to function
	subscriptionless bool
}

func init() {
	register.Register("OpenPcap", NewOpenPcapHandler())
}

// NewOpenPcapHandler generates a new OpenPcap Handler
func NewOpenPcapHandler() *OpenPcap {
	act := &OpenPcap{
		Cfg: &property.Configuration{
			Properties: make([]*property.Property, 0),
		},
		Name: "OpenPcap",
	}
	return act
}

// GetHandlerName should return the name of the handler that was used in register
func (a *OpenPcap) GetHandlerName() string {
	return a.Name
}

// Handle is used to open a pcap and output all network packets
func (a *OpenPcap) Handle(input payload.Payload) ([]payload.Payload, error) {

	path := string(input.GetPayload())
	file, err := pcap.OpenOffline(path)
	if err != nil {
		return nil, err
	}
	defer func() {
		file.Close()
	}()

	packets := gopacket.NewPacketSource(file, file.LinkType())

	sources := payload.BasePayload{
		Source:  "OpenPcap",
		Payload: packets,
	}
	output := make([]payload.Payload, 0)
	output = append(output, sources)
	return output, nil
	/*
	   // ReadPcap reads a pcap and prints all packets
	   // argument can be a filter to onlly take certain packets
	   func ReadPcap(path string, bpf string) (*gopacket.PacketSource,error) {
	   	handle, err := pcap.OpenOffline(path)
	   	if err != nil {
	   		return nil, err
	   	}
	   	//defer handle.Close()

	   	// apply filter if not empty
	   	if bpf != "" {
	   		// error checking ?? in teh future
	   		err = handle.SetBPFFilter(bpf)
	   		if err != nil {
	   			return nil, err
	   		}
	   	}

	   	return gopacket.NewPacketSource(handle, handle.LinkType()), nil
	   }

	*/

}

// ValidateConfiguration is used to see that all needed configurations are assigned before starting
func (a *OpenPcap) ValidateConfiguration() (bool, []string) {
	// Check if Cfgs are there as needed
	valid, miss := a.Cfg.ValidateProperties()
	if !valid {
		return valid, miss
	}
	return true, nil
}

// GetConfiguration will return the CFG for the Handler
func (a *OpenPcap) GetConfiguration() *property.Configuration {
	return a.Cfg
}

// Subscriptionless will return true/false if the Handler is genereating payloads itself
func (a *OpenPcap) Subscriptionless() bool {
	return a.subscriptionless
}
