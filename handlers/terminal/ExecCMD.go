// Package terminal is generated by Handlergenerator tooling
// Make sure to insert real Description here
package terminal

import (
	"bytes"
	"errors"
	"fmt"
	"os/exec"
	"strings"

	"github.com/perbol/workflow/payload"
	"github.com/perbol/workflow/property"
	"github.com/perbol/workflow/register"
)

// ExecCMD is used to execute a commandline command. This can be used to extend and use functions that are not part of the Workflow atm.
type ExecCMD struct {
	// Cfg is values needed to properly run the Handle func
	Cfg  *property.Configuration `json:"configs" yaml:"configs"`
	Name string                  `json:"handler_name" yaml:"handler_name"`
	// command is the command to run in terminal
	command string
	// arguments is a set of arugments to include in the command
	arguments []string
	// Subscriptionless is set to true if Payload is set in the arguments
	subscriptionless bool
}

var (
	// ErrNoPayload is thrown when trying to exec command with empty payload
	ErrNoPayload = errors.New("cannot execute a payload command with empty payload")
	// ErrEmptyCommand is when trying to run Exec without a Command set
	ErrEmptyCommand = errors.New("cannot run this Handler without a command set in configuration, also make sure ValidateConfiguration is run")
)

func init() {
	register.Register("ExecCMD", NewExecCMDHandler())
}

// NewExecCMDHandler generates a new ExecCMD Handler
func NewExecCMDHandler() *ExecCMD {
	act := &ExecCMD{
		Cfg: &property.Configuration{
			Properties: make([]*property.Property, 0),
		},
		Name: "ExecCMD",
	}
	act.Cfg.AddProperty("command", "the command to run ", true)
	act.Cfg.AddProperty("arguments", "The arguments to add to the command, if this list of arguments contains the word payload, It will print the payload of the incomming payload as an argument", false)

	return act
}

// GetHandlerName is used to retrun a unqiue string name
func (a *ExecCMD) GetHandlerName() string {
	return a.Name
}

// Handle is used to execute a Command if its set and ValidateConfiguration has been
// properly run
func (a *ExecCMD) Handle(input payload.Payload) ([]payload.Payload, error) {

	if a.subscriptionless {
		// If subscriptionless is true we dont need payloads so payload is probably NIL
		pay, err := a.Exec(nil)
		if err != nil {
			return nil, err
		}

		return []payload.Payload{pay}, nil
	}
	pay, err := a.Exec(input)
	if err != nil {
		return nil, err
	}

	return []payload.Payload{pay}, nil
}

// Exec will execute the command
func (a *ExecCMD) Exec(input payload.Payload) (payload.Payload, error) {
	if a.command == "" {
		return nil, ErrEmptyCommand
	}
	command := a.command
	for _, value := range a.arguments {
		if strings.Contains(value, "payload") {
			// If payload argument is set it is used to insert payload here, so it cannot be nil
			if input == nil {
				return nil, ErrNoPayload
			}
			payFlag := strings.Replace(value, "payload", string(input.GetPayload()), -1)
			command += " " + payFlag
		} else {
			command += " " + value
		}
	}

	// Lets Exec the command
	fullCmd := exec.Command("bash", "-c", command)
	var stdout, stderr bytes.Buffer
	fullCmd.Stderr = &stderr
	fullCmd.Stdout = &stdout
	err := fullCmd.Run()
	if err != nil {
		return nil, fmt.Errorf("%s:%w", fullCmd.String(), err)
	}

	errStr := string(stderr.Bytes())
	if errStr != "" {
		return nil, errors.New(errStr)
	}
	newPayload := &payload.BasePayload{
		Payload: stdout.Bytes(),
		Source:  fullCmd.String(),
	}
	return newPayload, nil
}

// ValidateConfiguration is used to see that all needed configurations are assigned before starting
func (a *ExecCMD) ValidateConfiguration() (bool, []string) {
	// Check if Cfgs are there as needed
	commandProp := a.Cfg.GetProperty("command")
	argumentsProp := a.Cfg.GetProperty("arguments")

	if commandProp.Value == nil {
		return false, []string{"Missing command property"}
	}

	command := commandProp.String()
	a.command = command

	if argumentsProp.Value != nil {
		splice, err := argumentsProp.StringSplice()
		if err != nil {
			return false, []string{err.Error()}
		}
		for _, arg := range splice {
			if arg == "payload" {
				// This should make INGRESS not required since we expect payloads
				a.subscriptionless = false
			}
		}
		a.arguments = splice

	}

	return true, nil
}

// GetConfiguration will return the CFG for the Handler
func (a *ExecCMD) GetConfiguration() *property.Configuration {
	return a.Cfg
}

// Subscriptionless will return true/false if the Handler is genereating payloads itself
func (a *ExecCMD) Subscriptionless() bool {
	return a.subscriptionless
}
