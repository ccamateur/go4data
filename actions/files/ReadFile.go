// Package files is generated by actiongenerator tooling
// Make sure to insert real Description here
package files

import (
	"io/ioutil"
	"os"

	"github.com/perbol/workflow/payload"
	"github.com/perbol/workflow/property"
	"github.com/perbol/workflow/register"
)

// ReadFile is used to ReadFiles data
type ReadFile struct {
	// Cfg is values needed to properly run the Handle func
	Cfg    *property.Configuration `json:"configs" yaml:"configs"`
	Name   string                  `json:"action" yaml:"action_name"`
	remove bool

	subscriptionless bool
}

func init() {
	register.Register("ReadFile", NewReadFileAction())
}

// NewReadFileAction generates a new ReadFile action
func NewReadFileAction() *ReadFile {
	act := &ReadFile{
		Cfg: &property.Configuration{
			Properties: make([]*property.Property, 0),
		},
		Name: "ReadFile",
	}
	act.Cfg.AddProperty("remove_after", "This property is used to configure if files that are read should be removed after", true)
	return act
}

// GetActionName is used to retrun a unqiue string name
func (a *ReadFile) GetActionName() string {
	return a.Name
}

// Handle is used to Read the content of a file from the former payload
// Expects a filepath in the input payload
func (a *ReadFile) Handle(input payload.Payload) ([]payload.Payload, error) {
	output := make([]payload.Payload, 0)

	path := string(input.GetPayload())
	file, err := os.Open(path)

	if err != nil {
		return nil, err
	}
	defer func() {
		file.Close()
		if a.remove {
			os.Remove(path)
		}
	}()
	data, err := ioutil.ReadAll(file)
	if err != nil {
		return nil, err
	}
	output = append(output, payload.BasePayload{
		Payload: data,
		Source:  "ReadFile",
	})

	return output, nil
}

// ValidateConfiguration is used to see that all needed configurations are assigned before starting
func (a *ReadFile) ValidateConfiguration() (bool, []string) {
	// Check if Cfgs are there as needed
	removeProp := a.Cfg.GetProperty("remove_after")
	missing := make([]string, 0)

	if removeProp == nil && removeProp.Value == nil {
		missing = append(missing, "remove_after")
		return false, missing
	}

	remove, err := removeProp.Bool()
	if err != nil {
		return false, nil
	}

	a.remove = remove

	return true, nil
}

// GetConfiguration will return the CFG for the action
func (a *ReadFile) GetConfiguration() *property.Configuration {
	return a.Cfg
}

// Subscriptionless will return true/false if the action is genereating payloads itself
func (a *ReadFile) Subscriptionless() bool {
	return a.subscriptionless
}
